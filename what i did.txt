i used cosedens fil structure for client folder.
now i pasted from chatgpt the package.json of the outside level of cleint and server .so it is the third package.json independent of both foolders. it has scripts to run both client and server at same time and many more. and ran "npm i" to install devdependacies. 
added .gitignore and pasted mern stack must gitignore files.
added read.MD for instructions

now i created a server folder. 
inside it i copied the file strcuture form web dev simplified yt channell. credited him in read.MD
now i initialized package npm init -y and setup package.json



BACKEND

now we look at the plan what to do in the backend
add dev:"nodemon server.js" to scripts of package.json 

in server.js file we define a express server.

import express from "express", 
define port variable.
use express() in const app = express() for simplicity
then start by app.listen(port, callabck)

now we need to run both client and server same time using concurrently and tweaking vite.config.js for smooth experince.

now add mongodb database and connect. download it tgz file then create a mongodb and data folder in your local drive anywhere. install mongdob.tgz in mongodb folder.

you need mongod server and mongoshell or compass. so run  ~/mongodb/bin/mongod --dbpath ~/data/db for mongod server or set path variable to simply enabling. in this command first is path of mongod and after that option and the path data directory data/db


nowe after settign mongo db in our project we creating database config in config folder, then a different models for different purposes like for user data we created a user model so we can create(signup) search and check( login) . etc and then create a router for sginpu and login in routes folder . then separate the logic for handling the request for userRoutes in the controller folder . then do this for all other features of backend.

USE AXIOS FOR API REQUEST. not fetch

after creating login and signup backend and validation of inputs after succesful login and signup apply jwt and local storage featurea and tehn naviator to home

/////////////////////////////////////////////////////////////
‚úÖ 1. Signup Flow
Frontend (React):

User fills form ‚Üí submits to /api/users/register

You validate fields (email, password length, etc.)

Send POST request with user data

On success:

Backend creates user + generates JWT

JWT is returned in response

‚úÖ You store token in localStorage

‚úÖ Show toast: ‚ÄúSignup successful! Welcome aboard üëã‚Äù

‚úÖ Use useNavigate("/") to redirect to homepage

js
Copy
Edit
localStorage.setItem("token", res.data.token);
toast.success("Signup successful! Welcome aboard üëã");
navigate("/");
‚úÖ 2. Login Flow
Frontend (React):

User fills email/password ‚Üí submits to /api/users/login

You validate inputs

Backend verifies credentials and returns JWT

‚úÖ You store token in localStorage

‚úÖ Show toast: ‚ÄúLogin successful!‚Äù

‚úÖ Redirect user to homepage or dashboard

js
Copy
Edit
localStorage.setItem("token", res.data.token);
toast.success("Login successful!");
navigate("/");
üîê 3. Protecting Auth Routes (Frontend)
You‚Äôll later:

Read the JWT from localStorage

Use it in headers for protected API calls:

js
Copy
Edit
headers: {
  Authorization: `Bearer ${token}`,
}
Optionally decode it to get user info (with jwt-decode)

Create a PrivateRoute component to protect routes like /profile
///////////////////////////////////////////////////////////////////////////////


now in backend we need to follwo this flow and on success create teh user and but we also need to validate again for backend also its a must practice.

USE OPENSSL COMMNAD TO GENREATE A JWT_SECRET (KEY) AND INSERT IT INTO ENV AND USE IT FOR JWT TOKEN CREATION. ( openssl rand -base64 32 )

now after genrating and sending jwt token in reponse in both singup and login controller, both saving the token in both login.jsx and signup.jsx we store them in local storage for proctect routes 
that needs to be proctected.

in next step we create a axiosInstance file in utils folder of frontend to get the token of the saved localstorage and send axios request to server to decode jwt and send us the users data,
so we can allow users to view their profile and access private routes.


//////////////////////////////////////////////////////////
Use axiosInstance instead of axios for protected requests:
const res = await axiosInstance.get("/users/profile");
/////////////////////////////////////////////////////////

next step is setting private routes 
create a privateRoute component in components folder, and use it wrap around teh proctected routes in the layout or app.jsx
here a nested object will be set inside the children array of the main object like path="/" its children array inside that we will set a object which have a element set as <PrivateRoute/> 
comonent whenever someone goes to proctected routes they will first go to lgoin if they have not lgoin or they have logined(they have valid jwt token) then they will access proctected routes.


now install jwt-decode npm package. and either create a decoder module.js in utils folder which is better since it will be used in signup too.
then we will use the data from the decoded jwt token and use the name and email from there to fill the profile details and this makes it look like the user is logged in.
this requires making the user data accessible through reactContext. we will create a context and then use its provider to provide a user varidable, a login user function and logout user 
function to all global access or whole app. by wrapping the router provider componet(our whole app in main .jsx) and then we can use the context values(user, loginuser function etc)
in any component by importing this context we created. this allows us to handle login and log out and set user details in any component needed. like we enable popup of account icon to 
show profile and dashboarf only when user is logged in and show user details. this is 2 or 3 different components work. so we need a global variable that we can use any where and we needed
loginuser and logout user in context provider because they have setUser() function which is needed to be global for us to use it anywhere and so login user and lgoout user functions needed
globalized too.

//////////////////////////////////////////////////////////
Use axiosInstance instead of axios for protected requests:
const res = await axiosInstance.get("/users/profile");
/////////////////////////////////////////////////////////
after this we will setup lgout feature.

now after this we will apply the feature token refresh
for that we have to create a util/helper function like generateRefreshToken for generating a refresh toekn which has different logic than access token
Here‚Äôs the step-by-step flow for clarity:

1. First Login

User enters credentials (email/password).

Server:

Verifies credentials.

Generates:

Access token (short expiry, e.g., 15 min)

Refresh token (long expiry, e.g., 7 days)

Sends both to the client.

Client stores:

Access token ‚Üí in memory (or short-term storage).

Refresh token ‚Üí in secure storage (HTTP-only cookie).

2. Using the Web App

Every API request includes the access token in the Authorization header.

Server checks the token ‚Äî if valid, request succeeds.

3. Token Expiration

Access token eventually expires.

Instead of showing ‚ÄúPlease log in again‚Äù:

Client automatically sends refresh token to /refresh endpoint.

Server verifies the refresh token and issues a new access token (and optionally a new refresh token).
Client updates its stored access token.
User continues using the app without re-entering credentials.
4. When Refresh Token Expires
User must log in again manually (full authentication).


note: basically if access token is compromised its compromised for like very little time (you set) , so access token is set to expire very early for security reasons, to get a new access token we need to send a request to the server for a new access token basically to refresh token when access token expires. here comes another token that server sends to you named refersh token. just like we need access token to access certain protected routes and send reques to their api, we also use a refersh token that we send to the server so server can check and say yes its him wanting a new ticket basically (token). so the server sends another access token and also another new refresh token because sending another refresh token is good for security because when access token is compromised its compromised for little time so after sometime if the attacker dont have a refresh token( which is stored in http only cookie for security). the attacker cant do any thing after access token is expired but if somehow the attacker get a refresh token what happens is the attacker use refresh token to get a new access token(which is also hard because he has to find a special /refresh endpoint). he may get the new access token but his refersh token is outdated because server sends new refersh token so basically again gets locked out and need to find the refresh token. 
if we only used access token and set its expiry time for like 30days the attacker if he gets the access token he will get a full access for 30days and then the original client cant do anything but contact the website admin to blacklist the access token and provide a new access token which is very bad practice and goes against jwt token features main motive.
Thats why we use refresh token

first we create a util function for generateing a refresh token
then modify login and signup controllers to send both access token and refresh token to client on request as response
then we creaet a special endpoint controller /api/users/refrsh to handle the request of new refrshing token


WE WILL APPLY REFRESH TOKEN WITH ROTATIION WHICH REQUIRES WE STORE BOTH ACCESS AND REFRSH TOKEN IN HTTP ONLY COOKIES

after setting refresh token we create a authMiddleware so whenever a request is sent to procted route(/getUserProfile etc) the middleware checks if accessToken is valid then it lets the client hit the intended endpoint route.

now after this we create a errorMiddleware which we first create a error for if a non existent endpoint is hit with (api/users/fdfhd like this) the error is sent to errorHandler() and the handler handles this error.
this error hanlde you must be wondering that how does it work, it is a trick that 
works like this:
the request come for a route express runs the server js , server js line by line goes until it reaches routes section which dont have a route for this request so program moves on and so we manually set a error and handle it in the end. so it is a trick
and for this we move the errorMiddlewares to the end of server js file.
on the client the not found page hanldes the pages but requests url is handled by server. like someone sent a axios request to the server like (api/users/xxxx) then server has to handle it.


now we need to validate mongoose user for server side too like we did in client side and also create a validator middleware

after this i tested the backend with postman and proceed to frontend tweak for thsi new http cookie only setup

now in front end ew need to tweak and create a new axios instance with {credentials: true}  after switcing to http only cookie auth based system
credentials : true is field that is must in both front end side and backend side becasue it allows the browser to send and recieve cookies in every request.
so instead of including this flag with every request we make in , we create a custom axios instance with credentials true.
in mern stack when we use this http only cookie based auth system we basically send and recieve cookie in every api request. we must create a custom axios instance

only in some request we dont need this credentials true flag.

we use api/ as base url in backend requests so we can differentiate between frontend pag routes and backend api routes

we need to create a axios instance for public api request and private api requests both has different credentials value both has differen interceptors.

when creating a public axios instance we need to know that interceptors help by preprocessing errors that come from axios so the component can handle it better.

now we create a private axios instance for sending request to protected private routes. there is a problem creating a interceptor for this instance , because we need
to use navigate() that is a hook , and hook can only be called inside a react component or top level of react component

after both axios instance are created lets fix our old token method in login.jsx and ssignup.jsx

first we remove token method and remove old auth context for global data handlinng. we create a new auth context that will have a feature of login and logout user and that has also featuer of fetching user info profile api that is a private page. or proctected page

we have a proctect middleware that is for proctected routes that requires access token so since checking if the user has access token to send user info the route of this (/me) must be used with protect middleware which has a access token checking system and it will be used for many endpoints thats why we created a middleware for this. but what about /refrsh , we can also create a middleware for proctection of this route that checks refresh token but since its not usefual because only this end point has this function not others no reusablity so we handle this in the route handler function of controllers itself.

üîπ Middleware in Express

It‚Äôs just a reusable function that runs between the request coming in and your controller handling it.

Purpose: move out repeated code from route handlers (like auth checks, logging, validation).

Signature: (req, res, next) => { ... }

Do something (check token, validate, etc).

Call next() if okay, or res.status(...).json(...) if not.																																																																																																					


we create a user, fetchUser(), logoutUser() in auth provider.
we first call /login endpoint to get the access token and then call fetchUser() to get user info and set global user.
then we hanlde logout by callinng logoutUser() which has a api request that goes to /logout endpoint to clear coookies(hanlded in bakcend) and set the user gloabbal as null value to remove user data on forntend.
now we tweak signup to have same logic as login but a little different
now we add a feature to authContext to be able to visit the website if user is loggd in then show that user is logged in on the wesbite. useEffect()
now we fix the porblme of expired token . 
expierd token is hanldeed by calling refersh for new access token. (refrsh strictmode caused problems calling /users/me twice causing problems in fetching /refersh and users/me when access token is expired but refrsh token is valid). this is only problem in devvelopment not production but we hanlded in dev by using a flag we created a ref variable and then when user effect run this gets true value , so it only allows one useEffect() run.

now to profile fetching

