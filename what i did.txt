i used cosedens fil structure for client folder.
now i pasted from chatgpt the package.json of the outside level of cleint and server .so it is the third package.json independent of both foolders. it has scripts to run both client and server at same time and many more. and ran "npm i" to install devdependacies. 
added .gitignore and pasted mern stack must gitignore files.
added read.MD for instructions

now i created a server folder. 
inside it i copied the file strcuture form web dev simplified yt channell. credited him in read.MD
now i initialized package npm init -y and setup package.json



BACKEND

now we look at the plan what to do in the backend
add dev:"nodemon server.js" to scripts of package.json 

in server.js file we define a express server.

import express from "express", 
define port variable.
use express() in const app = express() for simplicity
then start by app.listen(port, callabck)

now we need to run both client and server same time using concurrently and tweaking vite.config.js for smooth experince.

now add mongodb database and connect. download it tgz file then create a mongodb and data folder in your local drive anywhere. install mongdob.tgz in mongodb folder.

you need mongod server and mongoshell or compass. so run  ~/mongodb/bin/mongod --dbpath ~/data/db for mongod server or set path variable to simply enabling. in this command first is path of mongod and after that option and the path data directory data/db


nowe after settign mongo db in our project we creating database config in config folder, then a different models for different purposes like for user data we created a user model so we can create(signup) search and check( login) . etc and then create a router for sginpu and login in routes folder . then separate the logic for handling the request for userRoutes in the controller folder . then do this for all other features of backend.

USE AXIOS FOR API REQUEST. not fetch

after creating login and signup backend and validation of inputs after succesful login and signup apply jwt and local storage featurea and tehn naviator to home

/////////////////////////////////////////////////////////////
‚úÖ 1. Signup Flow
Frontend (React):

User fills form ‚Üí submits to /api/users/register

You validate fields (email, password length, etc.)

Send POST request with user data

On success:

Backend creates user + generates JWT

JWT is returned in response

‚úÖ You store token in localStorage

‚úÖ Show toast: ‚ÄúSignup successful! Welcome aboard üëã‚Äù

‚úÖ Use useNavigate("/") to redirect to homepage

js
Copy
Edit
localStorage.setItem("token", res.data.token);
toast.success("Signup successful! Welcome aboard üëã");
navigate("/");
‚úÖ 2. Login Flow
Frontend (React):

User fills email/password ‚Üí submits to /api/users/login

You validate inputs

Backend verifies credentials and returns JWT

‚úÖ You store token in localStorage

‚úÖ Show toast: ‚ÄúLogin successful!‚Äù

‚úÖ Redirect user to homepage or dashboard

js
Copy
Edit
localStorage.setItem("token", res.data.token);
toast.success("Login successful!");
navigate("/");
üîê 3. Protecting Auth Routes (Frontend)
You‚Äôll later:

Read the JWT from localStorage

Use it in headers for protected API calls:

js
Copy
Edit
headers: {
  Authorization: `Bearer ${token}`,
}
Optionally decode it to get user info (with jwt-decode)

Create a PrivateRoute component to protect routes like /profile
///////////////////////////////////////////////////////////////////////////////


now in backend we need to follwo this flow and on success create teh user and but we also need to validate again for backend also its a must practice.

USE OPENSSL COMMNAD TO GENREATE A JWT_SECRET (KEY) AND INSERT IT INTO ENV AND USE IT FOR JWT TOKEN CREATION. ( openssl rand -base64 32 )

now after genrating and sending jwt token in reponse in both singup and login controller, both saving the token in both login.jsx and signup.jsx we store them in local storage for proctect routes 
that needs to be proctected.

in next step we create a axiosInstance file in utils folder of frontend to get the token of the saved localstorage and send axios request to server to decode jwt and send us the users data,
so we can allow users to view their profile and access private routes.


//////////////////////////////////////////////////////////
Use axiosInstance instead of axios for protected requests:
const res = await axiosInstance.get("/users/profile");
/////////////////////////////////////////////////////////

next step is setting private routes 
create a privateRoute component in components folder, and use it wrap around teh proctected routes in the layout or app.jsx
here a nested object will be set inside the children array of the main object like path="/" its children array inside that we will set a object which have a element set as <PrivateRoute/> 
comonent whenever someone goes to proctected routes they will first go to lgoin if they have not lgoin or they have logined(they have valid jwt token) then they will access proctected routes.


now install jwt-decode npm package. and either create a decoder module.js in utils folder which is better since it will be used in signup too.
then we will use the data from the decoded jwt token and use the name and email from there to fill the profile details and this makes it look like the user is logged in.
this requires making the user data accessible through reactContext. we will create a context and then use its provider to provide a user varidable, a login user function and logout user 
function to all global access or whole app. by wrapping the router provider componet(our whole app in main .jsx) and then we can use the context values(user, loginuser function etc)
in any component by importing this context we created. this allows us to handle login and log out and set user details in any component needed. like we enable popup of account icon to 
show profile and dashboarf only when user is logged in and show user details. this is 2 or 3 different components work. so we need a global variable that we can use any where and we needed
loginuser and logout user in context provider because they have setUser() function which is needed to be global for us to use it anywhere and so login user and lgoout user functions needed
globalized too.

//////////////////////////////////////////////////////////
Use axiosInstance instead of axios for protected requests:
const res = await axiosInstance.get("/users/profile");
/////////////////////////////////////////////////////////
after this we will setup lgout feature.

now after this we will apply the feature token refresh
for that we have to create a util/helper function like generateRefreshToken for generating a refresh toekn which has different logic than access token
Here‚Äôs the step-by-step flow for clarity:

1. First Login

User enters credentials (email/password).

Server:

Verifies credentials.

Generates:

Access token (short expiry, e.g., 15 min)

Refresh token (long expiry, e.g., 7 days)

Sends both to the client.

Client stores:

Access token ‚Üí in memory (or short-term storage).

Refresh token ‚Üí in secure storage (HTTP-only cookie).

2. Using the Web App

Every API request includes the access token in the Authorization header.

Server checks the token ‚Äî if valid, request succeeds.

3. Token Expiration

Access token eventually expires.

Instead of showing ‚ÄúPlease log in again‚Äù:

Client automatically sends refresh token to /refresh endpoint.

Server verifies the refresh token and issues a new access token (and optionally a new refresh token).
Client updates its stored access token.
User continues using the app without re-entering credentials.
4. When Refresh Token Expires
User must log in again manually (full authentication).


note: basically if access token is compromised its compromised for like very little time (you set) , so access token is set to expire very early for security reasons, to get a new access token we need to send a request to the server for a new access token basically to refresh token when access token expires. here comes another token that server sends to you named refersh token. just like we need access token to access certain protected routes and send reques to their api, we also use a refersh token that we send to the server so server can check and say yes its him wanting a new ticket basically (token). so the server sends another access token and also another new refresh token because sending another refresh token is good for security because when access token is compromised its compromised for little time so after sometime if the attacker dont have a refresh token( which is stored in http only cookie for security). the attacker cant do any thing after access token is expired but if somehow the attacker get a refresh token what happens is the attacker use refresh token to get a new access token(which is also hard because he has to find a special /refresh endpoint). he may get the new access token but his refersh token is outdated because server sends new refersh token so basically again gets locked out and need to find the refresh token. 
if we only used access token and set its expiry time for like 30days the attacker if he gets the access token he will get a full access for 30days and then the original client cant do anything but contact the website admin to blacklist the access token and provide a new access token which is very bad practice and goes against jwt token features main motive.
Thats why we use refresh token

first we create a util function for generateing a refresh token
then modify login and signup controllers to send both access token and refresh token to client on request as response
then we creaet a special endpoint controller /api/users/refrsh to handle the request of new refrshing token


WE WILL APPLY REFRESH TOKEN WITH ROTATIION WHICH REQUIRES WE STORE BOTH ACCESS AND REFRSH TOKEN IN HTTP ONLY COOKIES

after setting refresh token we create a authMiddleware so whenever a request is sent to procted route(/getUserProfile etc) the middleware checks if accessToken is valid then it lets the client hit the intended endpoint route.

now after this we create a errorMiddleware which we first create a error for if a non existent endpoint is hit with (api/users/fdfhd like this) the error is sent to errorHandler() and the handler handles this error.
this error hanlde you must be wondering that how does it work, it is a trick that 
works like this:
the request come for a route express runs the server js , server js line by line goes until it reaches routes section which dont have a route for this request so program moves on and so we manually set a error and handle it in the end. so it is a trick
and for this we move the errorMiddlewares to the end of server js file.
on the client the not found page hanldes the pages but requests url is handled by server. like someone sent a axios request to the server like (api/users/xxxx) then server has to handle it.


now we need to validate mongoose user for server side too like we did in client side and also create a validator middleware

after this i tested the backend with postman and proceed to frontend tweak for thsi new http cookie only setup

now in front end ew need to tweak and create a new axios instance with {credentials: true}  after switcing to http only cookie auth based system
credentials : true is field that is must in both front end side and backend side becasue it allows the browser to send and recieve cookies in every request.
so instead of including this flag with every request we make in , we create a custom axios instance with credentials true.
in mern stack when we use this http only cookie based auth system we basically send and recieve cookie in every api request. we must create a custom axios instance

only in some request we dont need this credentials true flag.

we use api/ as base url in backend requests so we can differentiate between frontend pag routes and backend api routes

we need to create a axios instance for public api request and private api requests both has different credentials value both has differen interceptors.

when creating a public axios instance we need to know that interceptors help by preprocessing errors that come from axios so the component can handle it better.

now we create a private axios instance for sending request to protected private routes. there is a problem creating a interceptor for this instance , because we need
to use navigate() that is a hook , and hook can only be called inside a react component or top level of react component

after both axios instance are created lets fix our old token method in login.jsx and ssignup.jsx

first we remove token method and remove old auth context for global data handlinng. we create a new auth context that will have a feature of login and logout user and that has also featuer of fetching user info profile api that is a private page. or proctected page

we have a proctect middleware that is for proctected routes that requires access token so since checking if the user has access token to send user info the route of this (/me) must be used with protect middleware which has a access token checking system and it will be used for many endpoints thats why we created a middleware for this. but what about /refrsh , we can also create a middleware for proctection of this route that checks refresh token but since its not usefual because only this end point has this function not others no reusablity so we handle this in the route handler function of controllers itself.

üîπ Middleware in Express

It‚Äôs just a reusable function that runs between the request coming in and your controller handling it.

Purpose: move out repeated code from route handlers (like auth checks, logging, validation).

Signature: (req, res, next) => { ... }

Do something (check token, validate, etc).

Call next() if okay, or res.status(...).json(...) if not.																																																																																																					


we create a user, fetchUser(), logoutUser() in auth provider.
we first call /login endpoint to get the access token and then call fetchUser() to get user info and set global user.
then we hanlde logout by callinng logoutUser() which has a api request that goes to /logout endpoint to clear coookies(hanlded in bakcend) and set the user gloabbal as null value to remove user data on forntend.
now we tweak signup to have same logic as login but a little different
now we add a feature to authContext to be able to visit the website if user is loggd in then show that user is logged in on the wesbite. useEffect()
now we fix the porblme of expired token . 
expierd token is hanldeed by calling refersh for new access token. (refrsh strictmode caused problems calling /users/me twice causing problems in fetching /refersh and users/me when access token is expired but refrsh token is valid). this is only problem in devvelopment not production but we hanlded in dev by using a flag we created a ref variable and then when user effect run this gets true value , so it only allows one useEffect() run.

now we extend profile data
1. first lets extender usermodel.js , add profile details and addresses and other settings etc in the user model. and we can create a subschema for address(since it has many data alone)
2. after creteing the user model we send name, email and profile image(if available) for user from backend. and user <Avatar> component from MUI library to display the user prfolie pic, intials letters or if pfp is availabel then show profile pic.

in the front end we recieve teh profile data and we display it in the profile.jsx using useEffect()

now in profile.jsx we need the profile updating feature so we send name and phone no etc details to backend in router.put(/profile). to update the profile data. using findByIdAndUpdate for mongo and resendthe updated data to client so client can upate local variable of profile data. to show new data. we validate all input fields in bothclient and frontend.

now we also need to be able to update profile picture. to upload profile picture we need multer middleware inn backend to handle multipart/data in backend
in routes.js we create a storage config(variable) to explain to backend where to save filedata of profile coming from backend. like a folder named upload/profile picture in server files.(this is low level method to save image files in the server files it self but at advanced level we use cloud services to fetch the image from)
in storage config we set destination and filenaming config to name the coming file from client as something 
 then we specify 
 const upload = multer({upload})
 to use this upload we specify in the middlewaer as put("/endpoint", upload.single("profileImgae"), controllerFunction) 
this line here is a middleware that means if client sends a file or a form field with "profileImage" name, this will upload a single file and let the controller handle the file.

NOTE : _   If you deploy to a cloud (Heroku, Vercel, etc.), the uploads/ folder won‚Äôt persist between restarts. In production, you‚Äôd normally use a storage service (like AWS S3 Cloudinary, etc.).

now in front end we handle the edit mode. in which there in inputs with a edit button on top of the profile image. we need to click it to trigger the whole process of profile image change
after clicking the edit profile pencil icon button the computer shows fiel upload screen and after uploading file we need to show the preview in the place of the old profile image
and then after saving the changes the backend saves the file in locacl or cloud storage in server side and then sends teh new profile

Step-by-step plan (high level)

Add a hidden <input type="file"> and a ref so your edit button can trigger it.

Keep a selectedFile state to hold the chosen File object.

Create a previewUrl using URL.createObjectURL(selectedFile) so you can display an immediate preview. Revoke that URL when it‚Äôs no longer needed.

On submit, build a FormData object, append text fields and (if present) profileImage file. The field name must match your multer call on backend (we used "profileImage").

Send privateAxios.put("/users/profile", formData, { headers: {"Content-Type":"multipart/form-data"} }).

Disable the Save button while uploading, and update profile state with server response on success. Clean up preview and selectedFile.

Why FormData?

Because you‚Äôre uploading a file with other fields. FormData lets you send files and text in the same HTTP request using multipart/form-data. Multer on the server will populate req.file and req.body accordingly.


now my process to use other divs in react instead of DOM manipulation we need to use useRef() and create a reference for the fileInput and we will be able to trigger and use the hidden image input after clicking the edit pencil button.
you must be thinking that why not a make file input and make it clickable to pick files. but this is not good for styling. so professional use a button to trigger the hidden file input
use button in label and hidden input
and add the hidden input below it with same id for the label
now after clicking label (or the penicl icon in disguise) should trigger the hidden file input (file picker client) and after picking file it should validate the file extensionn and file size) after the validation we need to creaet a state variable selectedFile and store the file in this variable.

now after storing the image file in the selectedFile variable, we need to let the client see the preview so we create a previewUrl variable that holds the url( temporary) for the selected image file.
we use useEffect() for creating, updating and clearing up after component mount, for previewUrl using createObjectURL, useEffect() was since objectURL creation is requires a api use here and also to clear up this object we need to useEffect() which replaced componentDidMount(), componentDidUpdate(), componentWillUnmount() , and these are required for handlign these side effects and also clearnin up. which is done by this syntax below:
return () => { **clear up logic**}

after this we show conditionally show new pfp using preview Url if it has non-null value .
after this we handle cancle by clearing object url, preview url, selected file object .
after this we handle submit by creating a new form data variable with FormData() api or constructor function because the normal json object is not able to hold raw binary data we have to use a enctype=multipart/form-data enabled form data which can done by creating a object with FormData() object so we can add image object url in this new multipart/form-data type form data object 

Summary

FormData is necessary when uploading files.

.append() simulates how fields exist in a normal form submission.

Text fields (name, phone) are appended so the backend gets them in the same request along with the file.

The file is appended separately with the correct field name for Multer.

after completing the pfp change . we proceeded to delete account. we showed a confirmation modal with password checking feature and then allowed hitting delete /profile endpoint to delete 
profile and show success modal when it was successful and redirect using windows.href to reload whole app.

now we go to change password form , after clicking change password the form apppears. we need front end validate the form before submitting the data.
after submitting data we need to create a /change-password POST endpoint handler to change password
in the handler we need to do these
Change Password Backend Flow

Auth required ‚Üí only logged-in users can hit this endpoint (/change-password).

Input ‚Üí oldPassword, newPassword, confirmPassword.

Validate on backend:

All fields present

newPassword === confirmPassword

Password strength (same rules as frontend: length, characters, no spaces)

Verify old password against the stored hash (using bcrypt).

Hash new password and update user in DB.

Optional: Invalidate old refresh tokens ‚Üí force re-login.

Response ‚Üí success message or error.


after completeing profile page. we go to home page that requires a product model, product endpoints
for products we need to download 25+ images from pexels.com and unsplash.com that gives free images. in put them in one folder

after setting imagee sin public folder of server files , we need to expose them to localhost:5000 server port and in turn be able to use them in client side
we must create or modify the product model to have featured product flag so we can displya featured products on homepage, just like this be able filter out based on gender, color, size, price range. and be able to apply but feature. we need to have certain properties in this model to do these featuers


